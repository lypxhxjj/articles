## 缺页异常如何统计？

```
ps -omajflt,minflt -p PID
```

存在两个结果：minflt代表小错误，是总的缺页异常错误；majflt代表大错误，是包含磁盘访问的缺页异常错误。

这个命令在mac下无法正常执行。

## mmap的本质是什么？
在进程的虚拟地址空间中，mmap用于分配位于堆和栈之间的区域的虚拟内存。一般这个区域就叫做映射区。

mmap的用法：
```

  #include <unistd.h>
    #include <sys/mman.h>

void* mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset);
```
根据用户即可大概的猜出实现原理（man mmap）：
1. addr：用户希望从这个地址申请空间。内核会参考这个信息，但不一定完全采用，比如如果这个地址不可行，会找一个相对较近的位置分配。如果希望内核一定采用，flags参数中包含 MAP_FIXED，此时能分配就分配，不能分配就报错；
2. length参数是希望本次分配内存的大小，即需要的虚拟内存大小。
3. prot，用于指定这块内存的权限，比如可读可写可执行，如果不指定，则默认为PROT_NONE，代表内存不可访问。
4. flags有多个作用，比如更新虚拟内存的可见性，描述是否关联底层文件。

比如从更新可见性角度来说，一旦更新了内存，其他进程是否可以见到。如果设置为了MAP_SHARED，则其他进程当然能看到；如果设置了MAP_PRIVATE，则其他进程是看不到修改的。MAP_PRIVATE的实现利用了写时复制技术。即当一个进程需要写这块虚拟内存时，会拷贝出来一个page执行写入，而不是原地写入。这种技术主要用于加载动态链接库。

从是否关联底层文件角度，MAP_ANONYMOUS代表了不关联内部文件，即后面的fd和offset参数会被忽略。此时虚拟内存会被初始化为0。

5. fd和offset参数代表了mmap关联到一个文件，即将文件中的内容从offset偏移位置，加载到mmap申请的虚拟内存中。这个时候可以使用普通指针的方式修改文件。（当然需要执行msync命令）

## 其他一些理解
mmap如果关联到了文件，在使用mmap返回值void*写这块内存区域的时候，并不会自动同步到文件，一般会在执行msync和unmmap的时候执行写入。感觉这个是合理的，因为mmap申请的空间可能很大，内核并不知晓同步哪一块的数据到文件。

从内核角度来看，执行一次mmap成功，其实这个进程就多了一个vm_struct结构。

## 几大用途
一般有四个用途：
1. 私有匿名映射，用于分配堆空间；
2. 共享匿名映射，用于父子进程之间通讯；
3. 私有文件映射，用于加载动态链接库；
4. 共享文件映射，用于多进程之间通讯。

1. 私有匿名映射，用于分配堆空间。glibc中的malloc函数的底层实现，使用的就是mmap。不清楚glibc是否使用了mmap的addr参数，使得分配的空间尽量靠近堆区，如果没有的话，那么实际分配的堆内存其实都是在堆区的上边的。

2. 私有文件映射，用于加载动态链接库；这里有两个点帮助理解：
（1）私有，强调修改对其他进程不可见。利用的是写时复制技术实现。所以不同进程间只要不写入，是完全可以共享这一块物理内存的，一旦写入，会出现写时复制行为；（从这个角度来讲，进程的虚拟地址空间都具有这个特性，比如代码区、数据区、堆区、栈区等）
（2）文件，强调底层存在一个文件相关联。

需要同时关联文件，又需要写时复制的代码区域，是动态链接库。动态链接库也存在自己的虚拟空间布局，比如代码区，数据区。代码区所有进程共享，数据区则按修改的需求实现写时复制。（所以这个就是动态链接在内核层面的实现，基于的是私有文件映射，动态链接库的一个例子是malloc位于动态链接库中）


3. 共享匿名映射。共享，强调修改对多个进程可见，一旦涉及到这种就是进程间通信了。而由于是匿名映射，即没有底层关键相关联，所以只能用于父子进程，父子进程可以共享虚拟内存区域。

4. 共享文件映射。同样，共享强调进程间通信，文件映射可以基于一个共享的文件，文件存在文件名信息，可以方便在不同的进程间传递信息。


总结来看，
1. 私有，强调进程间虚拟地址空间隔离的那部分，虽然这部分隔离，但是其实还是可以多进程共享读的。直到存在写，才会发生写时复制，虚拟地址对应的物理内存才会彻底分离。所以私有代表：进程自己的地址空间 + 写时复制。（这块不太好理解，使用也很奇葩，需要反复琢磨）
2. 共享，强调进程间通信，就看有无关联底层文件，有的话，就可以实现任意进程通信；否则只能实现父子进程通信。

从内核角度来看，共享匿名映射是最麻烦的。
1. 为啥其他的不麻烦？私有匿名映射，相当于申请了一块进程自己的虚拟空间，可以直接复用fork的写时复制技术；基于文件的映射，不论私有共享，内核都只需要维护磁盘文件块到物理内存页之间的关联关系就好了。不同进程基于文件可能得到不同的虚拟空间地址，内核负责将虚拟空间地址映射到正确的物理地址上去。
2. 为啥共享匿名映射麻烦。因为匿名映射没有文件，父子进程其中一个访问了共享内存区，会触发缺页异常，并分配物理页面，但是另一个再次访问，内核不知晓应该分配同一个物理页面。
3. 如何解决？虚拟inode技术。即使是匿名映射，也关联到一个虚拟的inode，这样，父子进程在分配物理页面的时候，就可以利用这个inode来分配到同一个物理页面了。

## 到底如何理解mmap的私有与共享的概念
私有代表共享读 + 写时复制写。

共享代表共享读写，无写时复制。

即不论是否私有，mmap都有共享的含义。私有说的是更新的可见性问题。

私有最常见的例子就是：每个进程都有自己的内存区域，比如代码区，数据区，堆区，栈区之类的。

## 到底如何理解mmap的文件与匿名的概念。
这个比较好理解，匿名即只分配物理内存，没有对应的磁盘文件。

主要区分下，mmap的文件可以用于干什么。
1. 用于进程间通信：即基于 文件 + mmap 实现的进程间通信；
2. 用于动态链接库：进程间共享文件，但同时需要写时复制。

## 如何基于mmap实现任意两个进程的进程间通信？
难点在于，如果实现任意两个进程间的通信，就必须使用 共享 + 文件 映射，所以必须创建一个底层文件，这个合理吗，是否可以不创建？

查了下使用mmap实现进程间通信的例子，基本都是argv[1]用于传递文件名，基于文件实现进程间通信。

注意一点是，mmap虽然映射的是同一个文件，但是在不同的进程中返回的虚拟地址空间是不同的。没有必要相同，只要使用页表映射到同一个物理页面就可以了。

## mmap只分配虚拟地址空间，不分配实际的物理内存，啥时候分配的？
缺页中断。mmap只是在进程中的task_struct 中创建了一个新的vm_area_struct结构，并没有完成页表的赋值、甚至物理页面的分配。

那缺页中断是如何判断哪一种缺页类型的？
1. 进程写虚拟内存，从页表中发现，当前页只读。（fork写时复制；mmap设置私有）
此时缺页异常会找到这个地址所在的vm_area_struct，发现这个内存区域是可写的，此时应该是写时复制导致的，查看物理页的引用计数，为1的话，则可将页表中当前页直接修改为可读写；否则，写时拷贝出一个新的页来；

2. 进程读写虚拟内存，页表中发现没有这一项。（数据区的读写；mmap映射内存）
同样缺页异常会找到这个地址所在的vm_area_struct，没找到直接崩溃；找到了，检查这个区域的权限是否符合。符合的话，分配物理内存并设置页表。

3. 进程通过mmap读写文件，页表中发现没有这一项。（代码区的读写；mmap映射文件）
缺页异常在检查vm_area_struct的时候，会检查其vm_file参数，这个参数代表这么内存区域是否关联到了文件，如果关联到了，那么处理逻辑是将数据从磁盘导入到内存，再设置页表。



